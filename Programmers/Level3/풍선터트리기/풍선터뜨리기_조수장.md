1. 풀이
  1) 요점
    - 하나씩 비교하는 것은 오래 걸릴 것이라 우선 생각
    - 결국 가장 작은 값이 유리하게 작용할 것이라 생각하여 
      **좌측 집단의 최솟값과 우측 집단의 최솟값을 비교해야 한다고 판단.
    - 우선 순위 큐를 사용하려 했으나 검사한 값을 좌측으로 넘겨주는 갱신 과정에서
      해당 값을 한 번에 찾아 한 번에 제거하는 과정이 비효율적인 자료구조라서 set으로 변경
      
  2) 순서
    - 좌우를 나눌 두 개의 셋을 만든다(left, right).
    - right에는 모든 값을, left에는 첫번 째 값을 넣는다.
      (**첫번 쨰 값도 비교할 대상이 필요**하기 때문)
    - 반복문을 수행하며 현재 값이 left의 최솟값보다 작고 right의 최솟값과도 작는 경우가 아니면 카운팅해준다.
      (두 최솟값보다 작은 경우는 1번의 기회마저도 불가능하기 때문에 not 연산으로 조건을 회피)
    - 카운팅이 끝나면 지금 값을 left에 넘겨주고 right에서 제거
      (**'O(N) = 1'**로 빨리 진행됨)      


```c++
#include <string>
#include <vector>
#include <algorithm>
#include <set>

using namespace std;

int solution(vector<int> a) {
    int answer = 0;
    set<int> left, right;
    
    for(int v : a)
        right.insert(v); 
    
    left.insert(a[0]);
    
    for(int v : a){
        answer = !(*(left.begin()) < v && *(right.begin()) < v) ? answer + 1 : answer;
        left.insert(v);
        right.erase(right.find(v));
    }
                   
    return answer;        
}
```
